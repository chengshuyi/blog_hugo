---
title: "虾皮一面"
date: 2020-08-17T22:22:06+08:00
description: ""
draft: true
tags: []
categories: []
---



> 二叉树的先序遍历，用非递归的方法



> 内核态和用户态有什么区别


> 如何判断系统在哪里消耗性能，如何定位程序哪里消耗高


> 看cpu消耗在哪里，进程定位到某个函数占用cpu百分比


> tcp和udp的区别


> tcp是怎么保证是可靠的


> 服务器发送数据send，是否可以确定用户已经收到了

> http cookie和session的区别


> get和post的区别，安全性的区别


> get的url长度有限制吗? post呢


> lru的实现

哈希+双向链表，哈希的值对应双向链表的指针，达到快速查找的效果，省去了遍历链表的过程；

> io复用模型，select和epoll

select的几大缺点：

1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
3. select支持的文件描述符数量太小了，默认是1024

epoll的解决方案

1. 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
2. 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。
3. 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以`cat /proc/sys/fs/file-max`察看,一般来说这个数目和系统内存关系很大。


> c++的多态

静态多态和动态多态：

* 静态多态：函数重载、泛型编程；
* 动态多态：虚函数表，用父类型指针指向其**子类的实例**，然后通过父类的指针调用实际子类的成员函数，这种技术可以让父类的指针有“多种形态”。

NOTE：虚函数表，让父类的虚函数表指针也就是子类实例的虚函数表指针（内存分布）；

![](https://gitee.com/chengshuyi/scripts/raw/master/img/1597908983(1).png)

C++标准规格说明书中说到，编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。也就是说，我们可以通过对象实例的地址得到这张虚函数表，然后可以遍历其中的函数指针，并调用相应的函数。

> gdb的原理

* 利用`ptrace`让父进程可以观察和控制其它进程的执行；
* 断点原理：修改进程对应地址的指令，改成int 3
* 


> 怎么发现内存泄漏



