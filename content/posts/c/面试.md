---
title: "面试"
date: 2020-04-02T13:53:51+08:00
description: ""
draft: true
tags: []
categories: []
---

<!--more-->
作者：丁哥开讲
链接：https://zhuanlan.zhihu.com/p/82217387
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

第1题，c语言有哪些核心的特征？可移植性很强。模块化能力很强。灵活性很高。加载速度和执行速度都很好。可扩展性很强。

第2题，c语言中有哪些基本的数据类型？Int整型。Float浮点型。Double双浮点型。Char单个字符。void特殊类型，不包含任何值。

第3题， 解释一下语义错误。在写程序的时候会有很多语义错误，比如说，拼错了命令，一个函数的参数个数错了， 数据类型不匹配，等等。

第4题， C语言中如何使用增加和减少语句?有两种方式:++， --或者传统的加和减。

第5题， 什么是一个编程语言的保留字?保留字是指语言库中使用的一些关键字。这些关键字不能用来做其他的事情，比如说定义一个变量或者函数等等。

第6题， 解释一下dangling pointer。首先我们说有一个指针指向一个变量的内存地址。一段时间以后这个变量被从内存地址的位置删除了。这样的指针称之为dangling pointer.

第7题，描述一下静态函数的用途。使用静态static关键字定义的函数称之为静态函数。这样的函数需要在相同的代码里调用。

第8题, abs和fabs的区别是什么?这两个函数都是用来取绝对值的。前者是针对整型的。后者是针对浮点型的。前者位于标准库stdlib.h里面。后者在math.h里面。

第9题, 说一下wild pointers。未初始化的指针称之为wild pointers。这些指针指向一个随意的内存地址。如果访问它们可能会导致很坏的程序行为，甚至导致程序崩溃。

第10题， ++a和a++的区别是什么?加加a的意思是先加后取值。A加加的意思是先取值后增加。

第11题， 单等号和双等号的区别是什么?单等号表示赋值运算符。双等号是等于条件判断运算符。

第12题，解释一下c语言的原型函数。原型函数是对一个函数的声明。它包含函数名，返回值和参数类型列表。int sum(int,int)

第13题， 解释一下数据类型的cyclic nature。在c语言中，当一个程序员给一个数据类型的变量赋值的时候，有可能会溢出。这种溢出不会产生编译错误。最终的赋值结果会根据数据类型溢出后的剩余而定。这种行为称为cyclic nature. Char, int, long int数据类型有这个特性。Further float, double和long double数据类型没有这个特性。

第14题, 说一下c语言的头文件和用途。头文件存放了原型函数的定义。这个文件又称为库文件。比如说printf和scanf存放在stdio.h里面。

第15题, 解释一下在调试过程中对代码进行注释的做法。这个做法称为commenting out。通过把一些代码屏蔽掉来判断或排除是否是这些代码造成的错误。

第16题， 说一下c语言中循环的类型。C语言中有4种循环类型。whilefordo whilenested loop

第17题, 什么是nested loop?一个循环包含在另一个循环中称为nested loop。第1个循环成为外循环。里面的循环称为内循环。内循环执行的次数作为总循环的次数。

第18题，c语言中函数的通常格式是怎样的？C语言的函数，包含4个部分。返回值， 函数名， 参数， 函数体。int test(imt y, int z){return y+z;}

第19题, 什么是指针的指针?指针的指针是指一个指向指针所在地址的指针。int a=5, *x=&a, **y=&x;

第20题, Break关键字在哪个地方使用?Break可以用在循环中和switch语句当中。是用来终止当前的循环或跳出switch。

第21题， 使用头文件时双引号和尖括号的区别是什么?使用双引号时，首先要在当前工作目录中查找这个头文件，如果找不到的话就会在内置的include path里面找。使用尖括号时，只会在当前工作目录中查找这个头文件。

第22题，什么是sequential访问文件?这种文件用来存储数据，在写数据的时候会按照按照一个序列模式。在读取的时候也是按照这个模式往外读取。

第23题， 如何向栈数据结构里面存储数据?这样的数据是先进后出的。只有顶部的数据才可以被访问到。存储的时候使用push，获取的时候使用pop。

第24题，C程序算法的意义是什么?算法的意义在于提高程序的执行效率，是注重空间的节省，还是注重时间的节省，是写算法时需要考虑的因素。

第25题，写一个c程序，输出下面的结果。11 21 2 31 2 3 41 2 3 4 5#include <stdio.h>int main() {int a;int b;for(a=1;a<6;a++){for(b=1;b<=a;b++){printf("%d",b);}printf("\n");}return 0;}

第26题, 如下条件判断运算符哪个在c语言里不可用?==, <>, <=, >=答案是<>。

第27题, 在c语言中可不可以用大括号包含一行代码?是的, 当然可以。很多程序员使用大括号来规范代码结构，不管是一行还是多行。

第28题, 描述一下modifier。Modifier是数据类型的前置，用来标识存储空间的大小。比如说在32位处理器系统中, 整形的长度为4bits。如果我们加了如下的modifier:Long Int 就可以存8 bits。Short Int 占 2 bits。

第29题, 在c语言中有哪些modifiers?ShortLongSignedUnsignedlong long

第30题， 在c语言中如何产生随机数?rand 函数就是用来产生随机数的，它可以产生任意从0开始的整数。

第31题, 能不能在整型中存放32768这个数?整数类型可以存放从-32768~32767之间的任何数值。但是32768不在这个范围之内。这个时候modifier是我们需要的东西。Long Int数据类型就可以存放这个数。

第32题, 在c语言中可以自定义头文件吗?是的, 当然可以, 定义完头文件以后可以存放函数的原型。使用的时候, 用include来包含这个文件的名字。

第33题，解释一下c语言中的动态数据结构。动态数据结构在访问内存方面非常高效。内存的访问，要因程序的需求而定。

第34题，什么是indirection?如果你定一个指针变量， 它指向一个值变量或者一个内存对象。在这种情况下，对这个值变量和对象来说没有一个直接的引用。这种情况就是indirection.但是如果我们声明一个变量，它对值来说就是一个直接的引用。

第35题， 在c语言中，什么时候会用到空指针?有三种情况，在c语言中会用到空指针。作为一个错误值。作为一个监测值。在一个递归数据结构中终止indirection。

第36题， 解释一下模块化编程。把主程序分成多个小的，可执行的模块称为模块化编程。这个概念是为了增强重用性。同时也提高了程序的可维护性。

第37题， Call by value和call by reference有什么区别?call by value传的是值。Call by reference传的是地址。

第38题，如何在c语言中定义一个字符串变量？使用char定义一个字符数组。

第39题, 在函数定义的时候何时用void?当函数没有返回值时，可以用void。

第40题, 什么是preprocessor directives?Preprocessor directives一般放在程序的开头。主要是用来指定调用库文件的。还有一个用途是用来定义一些常值变量，宏定义等等。#开头。

第41题， 这样赋值对不对？错在哪里?myName="test";不对。我们不能用等号给一个字符串赋值。需要使用strcpy。

第42题，为什么c语言被认为是中级语言?这是因为c语言既能像高级语言那样编写程序，又可以像低级语言如汇编那样直接操作硬件。

第43题， 什么是链表?链表是一系列的元素连接在一起形成的数据结构。在c语言中，链表是用指针来构建的。使用链表数据结构是使用内存操作比较的一种方式。第44题，什么是fifo？First in first out. 队列是典型的first in first out，数据结构。

第45题, 什么是二叉树?二叉树是链表的延伸。它的每一个节点都有两个指针，一个指向左，一个指向右。

第46题， C语言中有些保留着是大写的对吗?不对，c语言中的所有保留字必须是小写，否则的话c的编译器会报错。第

47题，什么是输出重定向？输出重定向是指把程序的输出，除了输出在屏幕上以外的另外选择， 比如说，输出到一个文件里。

第48题， 什么是全局变量，如何定义它们?全局变量是指在程序中任何地方都可以访问到的变量。它一般定义在preprocessor directives的后面。

第49题, getch和getche, 这两个函数的区别是什么？前者是把用户的输入分配给一个变量。后者是把用户的输入打印到屏幕上，同时分配给一个变量。

第50题，文本文件和二进制文件的区别是什么？文本文件存放的是人类可以阅读的内容，它包含字母数字和其他的字符。而二进制文件存放的是1和0，只有电脑才能够读懂。

第51题，如何用随机访问的方法在一个数据文件中搜索数据?fseek在文件打开以后提供三个参数给这个函数。一个是文件的指针，一个是要搜索的字节数，再一个是文件中的搜索起点。

第52题, 在c语言中有没有内置的排序函数?qsort

第53题，heap的优点和缺点是什么？在heap上存放数据，要比在stack上存放数据要慢。但是使用heap的主要优势是灵活性。这是因为内存的访问, 分配以及删除可以按照任意顺序来执行。通过好的算法和设计可以规避heap速度慢的问题。

第54题，如何把字符串变成数字？atoi atof使用c语言里面的内置函数可以做到。你也可以自己写函数。码字不易，请关注点赞！



> static关键字的作用

1. static用于修改标识符的链接属性，将其链接属性从**外部链接**转换成内部链接，使得改标识符只能由该源文件访问，但标识符的存储期和作用域不受影响；

   > 外部链接和内部链接的存储期和作用域都一样，属于：文件作用域，静态存储期

2. static用于块作用域的标识符声明时，将其从自动变量转换成静态变量，但变量的链接属性和作用域不受影响。

3. 新的用法告知编译器如何使用形式参数；`double stick(double ar[static 20]);`static的这种用法表明了函数调用中的实际参数是一个指向数组首元素的指针，且该数组至少有20个元素。**目的是让编译器使用这些信息优化函数的编码。**

> extern关键字的作用

1. 表明该对象在其他地方分配
2. extern "C"的作用是让 C++ 编译器将extern "C"声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接。



> sizeof和strlen的区别

1. sizeof是运算符，而strlen是函数；

2. sizeof的用法是sizeof(参数)，这个参数可以是数组，指针，类型，对象，甚至是函数（新版的编译器会提示error或者warning），其值在编译的时候就计算好了，而strlen的参数必须是字符型指针（char*）,其值必须在函数运行的时候才能计算出来；
3. sizeof的功能是获得保证能容纳实现的建立的最大对象的字节的大小，而strlen的功能是返回字符串的长度；

4. 当数组作为参数传递给函数的时候，传的是指针，而不是数组，传递数组的首地址；

```cpp
char str[20] = "0123456789";
int a = strlen(str);  			//10
int b = sizeof(str);			//20
```

四、指针和引用的区别



（1）指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

（2）指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

（3）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化

（4）指针的值在初始化后可以改变，即指向其它的存储单元，而引用初始化后就不会再改变。

（5）"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小。

（6）作为参数传递时，二者有本质不同：指针传参本质是值传递，被调函数的形参作为局部变量在栈中开辟内存以存放由主调函数放进来的实参值，从而形成实参的一个副本。而引用传递时，被调函数对形参的任何操作都会通过一个间接寻址的方式影响主调函数中的实参变量。

如果想通过指针参数传递来改变主调函数中的相关变量，可以使用指针的指针或者指针引用。

五 、指针数组、数组指针、函数指针



指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。

数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。

一个小栗子：



```cpp
    int arr[] ={1,2,3,4,5};
    int *ptr =(int *)(&arr+1);  //2  5
    int *ptr =(int *)(arr+1);   //2  1
    cout<<*(arr+1)<<" "<<*(ptr-1)<<endl;
//数组名arr可以作为数组的首地址，而&a是数组的指针。
//arr和&arr指向的是同一块地址，但他们+1后的效果不同，arr+1是一个元素的内存大小（增加4）
//而&arr+1增加的是整个数组的内存
```

数组指针(行指针)

```cpp
    int a[2][3] = {{1,2,3},{4,5,6}};
    int (*p)[3];
    p = a;
    p++;
    cout<<**p<<endl;  //4  the second rank
```



六、C++内存布局

C/C++程序编译时内存分为5大存储区



（1）栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量值等，其操作方法类似数据结构中的栈。

（2）堆区（heap）：一般由程序员分配释放，与数据结构中的堆毫无关系，分配方式类似于链表。

（3）全局/静态区（static）：全局变量和静态变量的存储是放在一起的，在程序编译时分配。

（4）文字常量区：存放常量字符串。

（5）程序代码区：存放函数体（类的成员函数、全局函数）的二进制代码



```cpp
int a=0; //全局初始化区
char *p1; //全局未初始化区
void main()
{
	int b; //栈
	char s[]="bb"; //栈
	char *p2; //栈
	char *p3="123"; //其中，“123\0”常量区，p3在栈区
	static int c=0; //全局区
	p1=(char*)malloc(10); //10个字节区域在堆区
	strcpy(p1,"123"); //"123\0"在常量区，编译器 可能 会优化为和p3的指向同一块区域
｝
```



C/C++内存分配有三种方式：



（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。

动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏。

另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

七、堆和栈的区别



（1）申请方式

stack:

由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间

heap:

需要程序员自己申请，并指明大小，在c中malloc函数



如p1 = (char *)malloc(10); 

在C++中用new运算符 

如p2 = (char *)malloc(10); 

但是注意p1、p2本身是在栈中的。 



（2）申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆： 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲 结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

（3）申请大小的限制及生长方向

栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也可能是1M，它是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小 。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

（4）申请效率的比较：

栈由系统自动分配，速度较快。但程序员是无法控制的。

堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.

另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

（5）堆和栈中的存储内容

栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

八、malloc/free 、new/delete区别



（1）malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。

（2）对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。

​     由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

（3）C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

（4）new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

九 、常见的内存错误及对策



（1）内存尚未分配成功，却使用了它；



解决办法：在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口使用assert(p != NULL) 进行检查，如果是用malloc或者new来申请的，应该用

if (p == NULL)或者 if (p != NULL)来进行防错处理。

（2）内存分配虽然成功，但是尚未初始化就引用它；

错误原因：一是没有初始化的观念，二是误以为内存的缺省初值全为零，导致引用初值错误（如数组）。

解决办法：内存的缺省初值是什么并没有统一的标准，尽管有些时候为零值，但是宁可信其有，不可信其无，无论以何种方式创建数组，都要赋初值。



（3）内存分配成功并初始化，但是超过了内存的边界；

这种问题常出现在数组越界，写程序是要仔细。

（4）忘记释放内存，造成内存泄露；

含有这种错误的函数每次被调用都会丢失一块内存，开始时内存充足，看不到错误，但终有一次程序死掉，报告内存耗尽。

（5）释放了内存却继续使用它

产生原因：1.程序中的对象调用关系过于复杂，难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

2.函数return语句写错了，注意不要返回指向“栈内存”的指针或者引用，因为该内存在函数体结束时理论上被自动销毁。

3.使用free或者delete释放了内存后，没有将指针设置为null,导致产生野指针。

解决办法：小心仔细。

内存管理需要遵循的规则



（1）用malloc 或者 new 申请内存之后，应该立即检查指针值是否为 NULL ，防止使用指针值为NULL的内存；

（2）不要忘记数组和动态内存赋初值，防止未被初始化的内存作为右值使用；

（3）避免数组或者指针下标越界，特别要当心“多1”或者“少1”的操作；

（4）动态内存的申请与释放必须配对，防止内存泄露；

（5）用free或者delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”；

十、字节对齐问题

为什么要使用字节对齐？



字节对齐是C/C++编译器的一种技术手段，主要是在可接受空间浪费的前提下，尽可能地提高对相同元素过程的快速处理。（比如32位系统，4字节对齐能使CPU访问速度提高）

需要字节对齐的根本原因在于CPU访问数据的效率问题。

字节对齐的原则



（1）结构体中每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会填充字节

（2）结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会填充字节。

当然这里还要考虑#pragma pack(n)伪指令的影响，如果有取较小值。



```cpp
// 用于测试的结构体
typedef struct MemAlign
{
	char a[18];	// 18 bytes
	double b;	// 08 bytes	
	char c;		// 01 bytes
	int d;		// 04 bytes
	short e;	// 02 bytes
}MemAlign;

//大小为：48字节
```



对于union：sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。

十一、0的比较判断，浮点数存储



\1. int型变量

if ( n == 0 )

if ( n != 0 )

\2. bool型

 if (value == 0)

if (value != 0)

\3. char*型

if(p == NULL) / if(p != NULL)

\5. 浮点型

const float EPSINON = 0.0000001;

if ((x >= - EPSINON) && (x <= EPSINON)



十二、内联函数有什么优点？内联函数和宏定义的区别



优点：函数会在它所调用的位置上展开。这么做可以消除函数调用和返回所带来的开销（寄存器存储和恢复），而且，由于编译器会把调用函数的代码和函数本身放在一起优化，所以也有进一步优化代码的可能。

内联函数使用的场合：对于简短的函数并且调用次数比较多的情况，适合使用内联函数。

内联函数和宏定义区别：



1)内联函数在编译时展开，而宏在预编译时展开

2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。

3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。

4)宏不是函数，而inline是函数

十三、调用惯例及printf变参实现



函数在被调用时，函数的调用方和被调用方对于函数时如何调用的必须有一个明确的规定。只有双方同时遵循同样的规定，函数才能够被正确调用。这样的规定被称为：调用惯例。



函数的调用惯例包含两个方面：



1.函数参数的传递顺序和方式



函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序，是从左往右压栈，还是从右往左压栈。



2.栈的维护方式



在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入的参数全部弹出，使得栈在函数调用前后保持一致。这个弹出的工作可以由函数调用方来完成，也可以由函数本身来完成。在不指定调用惯例的情况下，默认采用cdecl惯例。



在这里插入图片描述

十四 、覆盖、重载、隐藏的区别



（1）重载：重载翻译自overload，是指同一可访问区内被声明的几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

（2）重写：重写翻译自override，是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致，只有函数体不同。



1.成员函数被重载的特征：



（1）相同的范围（在同一个类中）；



（2）函数名字相同；



（3）参数不同；



（4）virtual 关键字可有可无。



2.覆盖是指派生类函数覆盖基类函数，特征是：



（1）不同的范围（分别位于派生类与基类）；



（2）函数名字相同；



（3）参数相同；



（4）基类函数必须有virtual 关键字。



3.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：



（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。



（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

十五、四种强制类型转换

static_cast( expression )



​    用于数值类型之间的转换，也可以用于指针之间的转换，编译时已经确定好，效率高，但需要保证其安全性。

​    a) 指针要先转换成void才能继续往下转换。

​    b) 在基类和派生类之间进行转换（必须有继承关系的两个类）

​    子类对象可以转为基类对象(安全)，基类对象不能转为子类对象(可以转换，但不安全，dynamic_cast可以实现安全的向下转换)。

​    static_cast不能转换掉expression的const、volatile、或者__unaligned属性



dynamic_cast < type-id> ( expression )



​    只能用于对象的指针和引用之间的转换，需要虚函数。

​    dynamic_cast会检查转换是否会返回一个被请求的有效的完整对象，否则返回NULL；

​    Type-id必须是类的指针、类的引用或者void *，用于将基类的指针或引用安全地转换成派生类的指针或引用。



const_cast < type-id> ( expression )



这个转换类型操纵传递对象的const属性，或者是设置或者是移除。

reinterpret_cast < type-id> ( expression )



用在任意指针类型之间的转换；以及指针与足够大的整数类型之间的转换，从整数到指针，无视大小。

隐式类型转换



​    两种常用的实现隐式类类型转换的方式：

​    a、使用单参数的构造函数或N个参数中有N-1个是默认参数的构造函数。

​    b、使用operator目标类型（） const

​    避免隐式转换：前面加explicit。





作者：覃榆西
链接：https://zhuanlan.zhihu.com/p/100070340
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



问题*1*：什么是预编译？何时需要预编译？

答：

预编译又称预处理，是整个编译过程最先做的工作，即程序执行前的一些预处理工作。主要处理*#*开头的指令。如拷贝*#include*包含的文件代码、替换*#define*定义的宏、条件编译*#if*等。*.*

何时需要预编译：

*1*、总是使用不经常改动的大型代码体。

*2*、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

问题*2*：写一个*“*标准*”*宏，这个宏输入两个参数并返回较小的一个

答*:#define MIN(x, y) ((x)<(y)?(x):(y)) //*结尾没有*;*

问题*3*：*#*与*##*的作用？

答：*#*是把宏参数转化为字符串的运算符，*##*是把两个宏参数连接的运算符。

例如：

*#define STR(arg) #arg*  则宏*STR(hello)*展开时为*”hello”*

*#define NAME(y) name_y* 则宏*NAME(1)*展开时仍为*name_y*

*#define NAME(y) name_##y* 则宏*NAME(1)*展开为*name_1*

*#define DECLARE(name, type) typename##_##type##_type*，

则宏*DECLARE(val, int)*展开为*int val_int_type*

问题*4*：如何避免头文件被重复包含？

答：

例如，为避免头文件*my_head.h*被重复包含，可在其中使用条件编译：

```text
#ifndef _MY_HEAD_H
#define _MY_HEAD_H /*空宏*/
/*其他语句*/
#endif
```

## *2* 关键字

问题*1*：*static*关键字的作用？

答：

*Static*的用途主要有两个，一是用于修饰存储类型使之成为静态存储类型，二是用于修饰链接属性使之成为内部链接属性。

*1*静态存储类型：

在函数内定义的静态局部变量，该变量存在内存的静态区，所以即使该函数运行结束，静态变量的值不会被销毁，函数下次运行时能仍用到这个值。

在函数外定义的静态变量——静态全局变量，该变量的作用域只能在定义该变量的文件中，不能被其他文件通过*extern*引用。

*2* 内部链接属性

 静态函数只能在声明它的源文件中使用。

问题*2*：*const*关键字的作用？

答：

*1*声明常变量，使得指定的变量不能被修改。

*const int a = 5;/\*a*的值一直为*5*，不能被改变**/*

*const int b; b = 10;/\*b*的值被赋值为*10*后，不能被改变**/*

*const int \*ptr; /\*ptr*为指向整型常量的指针，*ptr*的值可以修改，但不能修改其所指向的值**/*

*int \*const ptr;/\*ptr*为指向整型的常量指针，*ptr*的值不能修改，但可以修改其所指向的值**/*

*const int \*const ptr;/\*ptr*为指向整型常量的常量指针，*ptr*及其指向的值都不能修改**/*

*2*修饰函数形参，使得形参在函数内不能被修改，表示输入参数。

如*int fun(const int a);*或*int fun(const char \*str);*

*3*修饰函数返回值，使得函数的返回值不能被修改。

*const char \*getstr(void);*使用：*const \*str= getstr();*

*const int getint(void);* 使用：*const int a =getint();*

问题*3*：*volatile*关键字的作用？

答：

*volatile*指定的关键字可能被系统、硬件、进程*/*线程改变，强制编译器每次从内存中取得该变量的值，而不是从被优化后的寄存器中读取。例子*:*硬件时钟*;*多线程中被多个任务共享的变量等。

问题*4*：*extern*关键字的作用？

答：

*1*用于修饰变量或函数，表明该变量或函数都是在别的文件中定义的，提示编译器在其他文件中寻找定义。

```text
extern int a;
extern int *p;
extern int array[];
extern void fun(void);
```

其中，在函数的声明带有关键字*extern*，仅仅是暗示这个函数可能在别的源文件中定义，没有其他作用。如：

头文件*A*：*A_MODULE.h*中包含

*extern int func(int a, int b);*

源文件*A: A_MODULE.c*中

```text
#include “A_MODULE.h”
int func(int a, int b)
{
 returna+b;
}
```

此时，展开头文件*A_MODULE.h*后，为

*extern int func(int a, int b);/**虽然暗示可能在别的源文件中定义，但又在本文件中定义，所以*extern*并没有起到什么作用，但也不会产生错误**/*

```text
int func(int a, int b)
{
 returna+b;
}
而源文件B：B_MODULE.c中，
#include “A_MODULE.h”
int ret = func(10,5);/
展开头文件A_MODULE.h后，为
extern int func(int a, int b);/*暗示在别的源文件中定义，所以在下面使用func(5,10)时，在链接的时候到别的目标文件中寻找定义*/
int ret = func(10,5);
```

*2* 用于*extern “c*

*extern “c”*的作用就是为了能够正确实现*C++*代码调用其他*C*语言代码。加上*extern "C"*后，会指示编译器这部分代码按*C*语言的编译方式进行编译，而不是*C++*的。

*C++*作为一种与*C*兼容的语言，保留了一部分面向过程语言的特点，如可以定义不属于任何类的全局变量和函数，但*C++*毕竟是一种面向对象的语言，为了支持函数的重载，对函数的编译方式与*C*的不同。例如，在*C++*中，对函数*void fun(int,int)*编译后的名称可能是*_fun_int_int*，而*C*中没有重载机制，一般直接利用函数名来指定编译后函数的名称，如上面的函数编译后的名称可能是*_fun*。

这样问题就来了，如果在*C++*中调用的函数如上例中的*fun(1,2)*是用*C*语言在源文件*a_module.c*中实现和编译的，那么函数*fun*在目标文件*a_module.obj*中的函数名为*_fun*，而*C++*在源文件*b_module.cpp*通过调用其对外提供的头文件*a_module.h*引用后，调用*fun*，则直接以*C++*的编译方式来编译，使得*fun*编译后在目标文件*b_module.obj*的名称为*_fun_int_int*，这样在链接的时候，因为*_fun_int_int*的函数在目标文件*a_module.obj*中不存在，导致了链接错误。

解决方法是让*b_module.cpp*知道函数*fun*是用*C*语言实现和编译了，在调用的时候，采用与*C*语言一样的方式来编译。该方法可以通过*extern “C”*来实现（具体用法见下面）。一般，在用*C*语言实现函数的时候，要考虑到这个函数可能会被*C++*程序调用，所以在设计头文件时，应该这样声明头文件：

```text
/*头文件a_module.h*/
/*头文件被CPP文件include时，CPP文件中都含有该自定义的宏__cplusplus*/
/*这样通过extern “C”告诉C++编译器，extern “C”{}里包含的函数都用C的方式来编译*/
#ifdef __cplusplus 
extern “C”
{
#endif
extern void fun(int a, int b);
#ifdef __cplusplus
}
#endif
```

*extern "C"*的使用方式

*1.* 可以是单一语句

   *extern "C" doublesqrt(double);*

*2.* 可以是复合语句*,* 相当于复合语句中的声明都加了*extern "C"*

```text
    extern "C"
  {
  double sqrt(double);
  int min(int, int);
  }
```

*3.*可以包含头文件，相当于头文件中的声明都加了*extern"C"*

```text
   extern "C"
  {
    #include <cmath>
  }
```

*4.* 不可以将*extern"C"* 添加在函数内部

*5.* 如果函数有多个声明，可以都加*extern"C",* 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。

*6.* 除*extern"C",* 还有*extern "FORTRAN"* 等。

问题*5*：*sizeof*关键字的作用？

答：

*sizeof*是在编译阶段处理，且不能被编译为机器码。*sizeof*的结果等于对象或类型所占的内存字节数。*sizeof*的返回值类型为*size_t*。

变量：*int a;* *sizeof(a)*为*4*；

指针：*int \*p;* *sizeof(p)*为*4*；

数组：*int b[10]; sizeof(b)*为数组的大小，*4\*10*；*int c[0]; sizeof(c)*等于*0*

结构体：*struct (int a; char ch;)s1;* *sizeof(s1)*为*8* 与结构体字节对齐有关。

注意：不能对结构体中的位域成员使用*sizeof*

*sizeof(void)*等于*1*

*sizeof(void \*)*等于*4*

## *3* 结构体

问题*1*：结构体的赋值？

答：

*C*语言中对结构体变量的赋值或者在初始化或者在定义后按字段赋值。

方式*1*：初始化

```text
struct tag
{
 chara;
 int b;
}x = {‘A’, 1};/*初始化*/
或
struct tag
{
char a;
int b;
};
struct tag x = {‘A’,1};/*在定义变量时初始化*/
```

*GNU C*中可使用另外一种方式：

```text
struct tag
{
char a;
int b;
}x =
{
.a = ‘A’,
.b =1;
};
或
struct tag
{
char a;
int b;
};
struct tag x =
{
 .a= ‘A’,
 .b=1,
};
```

方式*2*：定义变量后按字段赋值

```text
struct tag
{
char a;
int b;
};
struct tag x;/*定义变量*/
x.a = ‘A’;/*按字段赋值*/
x.b = 1; /*按字段赋值*/
```

而当你使用初始化的方式来赋值时，如*x = {‘A’,1};*则出错。

方式*3*：结构变量间的赋值

```text
struct tag
{
 chara;
 int b;
};
struct tag x,y;
x.a=’A’;
x.b=1;
y = x;/*结构变量间直接赋值*/
```

问题*2*：结构体变量如何比较？

答：虽然结构体变量之间可以通过*=*直接赋值，但不同通过比较符如*==*来比较，因为比较符只作用于基本数据类型。这个时候，只能通过*int memcmp(const void \*s1, const void \*s2, size_t n);*来进行内存上的比较。

问题*3*：结构体位域

答：

位域是一个或多个位的字段，不同长度的字段（如声明为*unsigned int*类型）存储于一个或多个其所声明类型的变量中（如整型变量中）。

位域的类型：可以是*char*、*short*、*int*，多数使用*int*，使用时最好带上*signed*或*unsigned*

位域的特点：字段可以不命名，如*unsignedint :1;*可用来填充；*unsigned int :0; 0*宽度用来强制在下一个整型（因此处是*unsigned int*类型）边界上对齐。

位域的定义：

```text
struct st1
{
unsigned chara:7;/*字段a占用了一个字节的7个bit*/
unsigned charb:2;/*字段b占用了2个bit*/
unsigned charc:7;/*字段c占用了7个bit*/
}s1;
```

*sizeof(s1)*等于*3*。因为一个位域字段必须存储在其位域类型的一个单元所占空间中*,*不能横跨两个该位域类型的单元。也就是说，当某个位域字段正处于两个该位域类型的单元中间时，只使用第二个单元，第一个单元剩余的*bit*位置补（*pad*）*0*。

于是可知*Sizeof(s2)*等于*3\*sizeof(int)*即*12*

```text
struct st2
{
unsigned inta:31;
unsigned intb:2;/*前一个整型变量只剩下1个bit，容不下2个bit，所以只能存放在下一个整型变量*/
unsigned int c:31;
}s2;
```

位域的好处：

​       *1.*有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有*0*和*1* 两种状态，用一位二进位即可。这样节省存储空间，而且处理简便。这样就可以把几个不同的对象用一个字节的二进制位域来表示。
​        *2.*可以很方便的利用位域把一个变量给按位分解。比如只需要*4*个大小在*0*到*3*的随即数，就可以只*rand()*一次，然后每个位域取*2*个二进制位即可，省时省空间。

位域的缺点：

不同系统对位域的处理可能有不同的结果，如位段成员在内存中是从左向右分配的还是从右向左分配的，所以位域的使用不利于程序的可移植性。

问题*4*：结构体成员数组大小为*0*

结构体数组成员的大小为*0*是*GNU C*的一个特性。好处是可以在结构体中分配不定长的大小。如

```text
typedef struct st
{
 inta;
int b;
char c[0];
}st_t;
sizeof(st_t)等于8，即char c[0]的大小为0.
#define SIZE 100
st_t *s = (st_t *)malloc(sizeof(st_t) + SIZE);
```

## *4* 函数

问题*1*：函数参数入栈顺序

答：

*C*语言函数参数入栈顺序是从右向左的，这是由编译器决定的，更具体的说是函数调用约定决定了参数的入栈顺序。*C*语言采用是函数调用约定是*__cdecl*的，所以对于函数的声明，完整的形式是：*int __cdecl func(int a, int b);*

问题*2*：*inline*内联函数

答：

*inline*关键字仅仅是建议编译器做内联展开处理，即是将函数直接嵌入调用程序的主体，省去了调用*/*返回指令。

## *5* 内存分配回收

问题*1*： *malloc/free*与*new/delete*的区别

答：

*1) malloc*与*free*是*C/C++*语言的标准库函数，*new/delete*是*C++*的运算符。它们都可用于申请动态内存和释放内存。

*2)* 对于非内部数据类型的对象而言，光用*maloc/free*无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于*malloc/free*是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于*malloc/free*。因此*C++*语言需要一个能完成动态内存分配和初始化工作的运算符*new*，以及一个能完成清理与释放内存工作的运算符*delete*。注意*new/delete*不是库函数。
我们不要企图用*malloc/free*来完成动态对象的内存管理，应该用*new/delete*。由于内部数据类型的*“*对象*”*没有构造与析构的过程，对它们而言*malloc/free*和*new/delete*是等价的。

*3)* 既然*new/delete*的功能完全覆盖了*malloc/free*，为什么*C++*不把*malloc/free*淘汰出局呢？这是因为*C++*程序经常要调用*C*函数，而*C*程序只能用*malloc/free*管理动态内存。
如果用*free*释放*“new*创建的动态对象*”*，那么该对象因无法执行析构函数而可能导致程序出错。如果用*delete*释放*“malloc*申请的动态内存*”*，结果也会导致程序出错，但是该程序的可读性很差。所以*new/delete*必须配对使用，*malloc/free*也一样。

问题*2*：*malloc(0)*返回值

答：如果请求的长度为*0*，则标准*C*语言函数*malloc*返回一个*null*指针或不能用于访问对象的非*null*指针，该指针能被*free*安全使用。

## *6* 可变参数列表

可变参数列表是通过宏来实现的，这些宏定义在*stdarg.h*头文件，它是标准库的一部分。这个头文件声明了一个类型*va_list*和三个宏：*va_start*、*va_arg*和*va_end*。

```text
typedef char *va_list;
#define va_start(ap, A)  (void)((ap) = (char *)&(A) + _Bnd(A, _AUPBND))
#define va_arg(ap, T) (*(T )((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND)))
#define va_end(ap) (void)0
int print(char *format, …)
```

宏*va_start*的第一个参数是*va_list*类型的变量，第二个参数是省略号前最后一个有名字的参数，功能是初始化*va_list*类型的变量，将其值设置为可变参数的第一个变量。

宏*va_arg*的第一个参数是*va_list*类型的变量，第二个参数是参数列表的下一个参数的类型。*va_arg*返回*va_list*变量的值，并使该变量指向下一个可变参数。

宏*va_end*是在*va_arg*访问完最后一个可变参数之后调用的。

问题*1*：实现*printf*函数

```text
/*（转载）
 * A simple printf function. Only support the following format:
 * Code Format
 * %c character
 * %d signed integers
 * %i signed integers
 * %s a string of characters
 * %o octal
 * %x unsigned hexadecimal
 */
int my_printf( const char* format, ...)
{
    va_list arg;
    int done = 0;

    va_start (arg, format); 

    while( *format != '\0')
    {
        if( *format == '%')
        {
            if( *(format+1) == 'c' )
            {
                char c = (char)va_arg(arg, int);
                putc(c, stdout);
            } else if( *(format+1) == 'd' || *(format+1) == 'i')
            {
                char store[20];
                int i = va_arg(arg, int);
                char* str = store;
                itoa(i, store, 10);
                while( *str != '\0') putc(*str++, stdout); 
            } else if( *(format+1) == 'o')
            {
                char store[20];
                int i = va_arg(arg, int);
                char* str = store;
                itoa(i, store, 8);
                while( *str != '\0') putc(*str++, stdout); 
            } else if( *(format+1) == 'x')
            {
                char store[20];
                int i = va_arg(arg, int);
                char* str = store;
                itoa(i, store, 16);
                while( *str != '\0') putc(*str++, stdout); 
            } else if( *(format+1) == 's' )
            {
                char* str = va_arg(arg, char*);
                while( *str != '\0') putc(*str++, stdout);
            }

            // Skip this two characters.

            format += 2;
        } else {
            putc(*format++, stdout);
        }
    }

    va_end (arg);

    return done;
} 
```



## *7* 其他

*问题1：ASSERT()*的作用

答*:ASSERT()*是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为*FALSE (0),* 程序将报告错误，并终止执行。如果表达式不为*0*，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量*n*在程序中不应该为*0*，如果为*0*可能导致错误，你可以这样写程序：

*......*

*ASSERT( n != 0);*

*k = 10/ n;*

*.....*

*ASSERT*只有在*Debug*版本中才有效，如果编译为*Release*版本则被忽略。

*assert()*的功能类似，它是*ANSI C*标准中规定的函数，它与*ASSERT*的一个重要区别是可以用在*Release*版本中。

*问题2：system("pause");*的作用

答*:*系统的暂停程序，按任意键继续，屏幕会打印，*"*按任意键继续。。。。。*"*省去了使用*getchar*（）；

*问题3：*请问*C++*的类和*C*里面的*struct*有什么区别？

答*:c++*中的类具有成员保护功能，并且具有继承，多态这类*oo*特点，而*c*里的*struct*没有。*c*里面的*struct*没有成员函数*,*不能继承*,*派生等等*.*



## *8* 找错题

试题1：

```text
void test1()
{
　　char string[10];
　　char* str1 = "0123456789";
　　strcpy(string, str1);
}
```

解答：字符串str1有11个字节（包括末尾的结束符'\0'），而string只有10个字节，故而strcpy会导致数组string越界。

试题2：

```text
void test2()
{
　　char string[10], str1[10];
　　int i;
　　for(i=0; i<10; i++)
　　{
　　    str1= 'a';
　　}
　　strcpy(string, str1);
}
```

解答：因为str1没有结束符'\0'，故而strcpy复制的字符数不确定。strcpy源码如下：

```text
#include <string.h>

char *strcpy(char *s1, cosnt char *s2)

{

char *s = s1;

for (s = s1; (*s++ = *s2++) != '\0';)/*最后的结束符'\0'也会被复制*/

;

return s1;

}
试题3：
void test3(char* str1)
{
　　char string[10];
　　if(strlen(str1) <= 10 )
　　{
　　    strcpy(string, str1);
　　}
}
```

解答：应修改为if (strlen(str1) < 10)，因为strlen的结果未统计最后的结束符'\0'。strlen的源码如下：

```text
#include <string.h>

size_t strlen(const char *s)

{

const char *sc;

for (sc = s; *sc != '\0'; ++sc)/*不包含最后的结束符'\0'*/

;

return (sc - s);

}
```

试题4：

```text
void GetMemory(char *p)
{
　　p = (char *)malloc( 100 );
}
void Test( void )
{
　 char *str = NULL;
　 GetMemory(str);
　 strcpy(str,"hello world");
　 printf(str);
}
```


解答：C语言中的函数参数为传值参数，在函数内对形参的修改并不能改变对应实参的值。故而调用GetMemory后，str仍为NULL。

试题5：

```text
char *GetMemory( void )
{
　　char p[] = "hello world";
　　return p;
}
void Test( void )
{
　　char *str = NULL;
　　str = GetMemory();
　　printf(str);
}
解答：GetMemory中，p为局部变量，在函数返回后，该局部变量被回收。故而str仍为NULL
```

试题6：

```text
void GetMemory( char **p, int num )
{
　　*p = (char *)malloc(num);
}
void Test( void )
{
　　char *str = NULL;
　　GetMemory(&str, 100);
　　strcpy(str, "hello");
　　printf(str);
}
```

解答：试题6避免了试题4的问题，但在GetMemory内，未对*p为NULL情况的判断。当*p不为NULL时，在printf后，也未对malloc的空间进行free

试题7：

```text
void Test( void )
{
　　char *str = (char *)malloc( 100 );
　　strcpy(str, "hello" );
　　free(str);
　　... //省略的其它语句
}
```

解答：未对str为NULL的情况的判断，在free(str)后，str未设置为NULL，可能变成一个野指针（后面对str的操作可能会导致踩内存）。

试题8：

```text
swap(int* p1,int* p2)
{
　　int *p;
　　*p = *p1;
　　*p1 = *p2;
　　*p2 = *p;
}
```

解答：在swap函数中，p是个野指针，可能指向系统区，导致程序运行的崩溃。故而，程序应改为：

```text
swap(int* p1,int* p2)
{
　　int p;
　　p = *p1;
　　*p1 = *p2;
　　*p2 = p;
}
```


*9* 编程题

题*1*：判断字符串*str2*是否在字符串*str1*里。



```text
#include <stdio.h>



#define OK 1

#define ERROR 0



int str_str(const char *str1, const char *str2)

{

const char *s1 = NULL;

const char *s2 = NULL;



if (str1 == NULL)

{

return (str2 == NULL) ? OK : ERROR;

}



if (str2 == NULL)

{

return OK;

}



for (; *str1 != '\0'; str1++)

{

if (*str1 == *str2)

{

for (s1 = str1, s2 = str2; ; )

{

if (*++s2 == '\0')

{

return OK;

}

else if (*++s1 != *s2)

{

break;

}

}

}

}



return ERROR;

}
```