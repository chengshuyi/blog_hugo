---
title: "记一次利用条件断点调试内存踩踏问题"
date: 2020-08-13T19:09:01+08:00
description: ""
draft: false
tags: [杂谈]
categories: [杂谈]
---

最近遇到一个bug，内存的数据被篡改，但是由于数据频繁变化、时间短（几毫秒更新一次）以及代码极多，无法利用单步调试确定是哪行代码修改了其内存数据。采用内存地址条件断点调试很快就解决了问题。

### 场景描述

有64位整数数组为`uint64_t result[0x10000000]`，外界通过http协议获取该数据的二进制，但是该数据有时会出现异常值。可以知道，`result`数据被任意的篡改了。难点在于代码多，无法很好的定位哪里修改了`result`。

### 解决方案

通过观察发现，`result[0]`每次都会被修改成整数`0x14d00000002`，因此可以插入内存条件断点：

1. 假设`result`的首地址为`0x12108920`，则插入内存条件断点为`*((uint64_t *)(0x12108920)) == 0x14d00000002`；
2. 运行程序，当条件成立时，程序自动停止，发现是全局变量重名的问题。在另外一个文件里面同样定义了一个`uint64_t result[]`的全局数组；

虽然问题很简单，但是也有不少启发：

1. 全局变量最好能用统一的文件进行维护；
2. 内存数据篡改可以利用内存条件断点找到修改数据的指令地址；
3. 可以采用反汇编搜索被篡改的内存地址，可以找到哪些函数或者指令修改了其数据；
3. 能用`static`就用`static`；

### 内存断点原理

内存断点是通过修改该物理地址对应的页面属性，比如设置成只读、只写或者不可读写。当有指令试图修改该地址对应的值就会触发异常，然后由异常处理函数接管会进行如下判断：

1. 判断是否有在该地址插入内存断点，有的话需要恢复该物理地址的属性，如变成可读可写的；
2. 如果是条件断点还需要判断可以判断是否满足条件，如果满足条件则需要设置一个单步调试断点。