---
title: "记一次利用条件断点调试内存踩踏问题"
date: 2020-08-13T19:09:01+08:00
description: ""
draft: true
tags: [杂谈]
categories: [杂谈]
---

最近遇到一个bug，内存的数据被篡改，但是由于数据频繁变化、时间短（几毫秒更新一次）以及代码极多，无法利用单步调试确定是哪行代码修改了其内存数据。采用内存地址条件断点调试很快就解决了问题。

### 场景描述

有64位整数数组为`uint64_t result[0x10000000]`，外界通过http协议获取该数据的二进制，但是该数据有时会出现异常值。可以知道，`result`数据被任意的篡改了。难点在于代码多，无法很好的定位哪里修改了`result`。

### 解决方案

通过观察发现，`result[0]`每次都会被修改成整数`0x14d00000002`，因此可以插入内存条件断点：

1. 假设`result`的首地址为`0x12108920`，则插入内存条件断点为`*((uint64_t *)(0x12108920)) == 0x14d00000002`；
2. 运行程序，当条件成立时，程序自动停止，发现是全局变量重名的问题。在另外一个文件里面同样定义了一个`uint64_t result[]`的全局数组；

虽然问题很简单，但是也有不少启发：

1. 能用`static`就用`static`；
2. 全局变量最后能用统一的文件进行维护；
3. 内存数据篡改可以利用内存条件断点找到修改数据的指令地址；

